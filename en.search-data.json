{"/larecs/guide/":{"data":{"":"This user guide provides a brief explanation of the main data types and functionality of LarecsÔªøüå≤. For new users it is advisable to go through it in the order of the side menu.\nFor a deeper dive into ECS and the architecture by Larecsüå≤, have a look at the ECS FAQ by Sander Mertens, the author of the Flecs ECS and the architecture section of the Arche ECS by Martin Lange, which served as the main inspiration for Larecsüå≤."},"title":"User guide"},"/larecs/guide/adding_and_removing_entities/":{"data":{"":"Adding and removing individual entities is done via the add_entity and remove_entity methods of World. Revisiting our earlier example of a world with Position and Velocity, this reads as follows:\n# Add an entity and get its representation entity = world.add_entity() # Remove the entity world.remove_entity(entity) Components can be added to the entities directly upon creation. For example, to create an entity with a position at (0, 0) and a velocity of (1, 0), we can do the following:\nentity = world.add_entity(Position(0, 0), Velocity(1, 0)) ","batch-addition#Batch addition":"If we want to create multiple entities at once, we can do this in a similar manner via add_entities:\n# Add a batch of 10 entities with given position and velocity _ = world.add_entities(Position(0, 0), Velocity(1, 0), count=10) In contrast to add_entity, which creates a single entity, add_entities returns an iterator over all newly created entities. Suppose, we want to place the entities all on a line, each one unit apart from the other, we could do this as follows:\n# Add a batch of 10 entities with given position and velocity x_position = 0 for entity in world.add_entities(Position(0, 0), Velocity(1, 0), count=10): entity.get[Position]().x = x_position x_position += 1 More information on manipulation of and iteration over entities is provided in the upcoming chapters.\nNote\nIterators block certain changes to the world and should not be stored in a variable. That is, use the result of add_entities only in the right hand side of for loops.","batch-removal#Batch removal":"If we want to remove multiple entities at once, we need to characterize which entities we mean. To that end, we use queries, which characterize entities by their components. For example, removing all entities that have the component Position can be done with remove_entities as follows:\n# Add a batch of 10 entities with given position and velocity world.remove_entities(world.query[Position]()) More on queries can be found in the chapter Queries and iteration.\nTip\nAdding and removing many components in one go is significantly more efficient than adding and removing components one by one."},"title":"Adding and removing entities"},"/larecs/guide/benchmarks/":{"data":{"":"","ecs-operations#ECS operations":"TODO: Tabular overview of the runtime cost of typical ECS operations. See Arche‚Äôs benchmarks for an example.","versus-array-of-structs#Versus Array of Structs":"The plots below show the iteration time per entity in the classical Position-Velocity example. That is, iterate all entities with components Position and Velocity, and add velocity to position:\nposition.x += velocity.x position.y += velocity.y The benchmark is performed with different amounts of ‚Äúpayload components‚Äù, where each of them has two Float64 fields, just like Position and Velocity. Further, the total number of entities is varied from 100 to 1 million.\nNote that the benchmarks run in the Github CI, which uses very powerful hardware. Particularly, the processors have 256MB of cache. On a laptop or desktop computer with typically much less cache, Larecsüå≤ will outperform AoS for everything but the smallest setups."},"title":"Benchmarks"},"/larecs/guide/changing_entities/":{"data":{"":"Entities may be changed by altering the values / attributes\nof their components, adding new components, or removing\nexisting components.","accessing-and-changing-individual-components#Accessing and changing individual components":"The values of an entity‚Äôs component can be accessed and changed via the get method of world.\nA reference to a component can be obtained as follows:\n# Add an entity with a component entity = world.add_entity(Position(0, 0)) # Get a reference to the position; ref pos = world.get[Position](entity) # We can change the reference. pos.x = 5 assert_equal(world.get[Position](entity).x, 5) # We can also replace the component completely. world.get[Position](entity) = Position(10, 0) assert_equal(world.get[Position](entity).x, 10) Of course, accessing a component only works if the entity has the component in question. Accessing a component that the entity does not have will result in an error.\n# Add an entity without a velocity component entity = world.add_entity(Position(0, 0)) with assert_raises(): # This will result in an error _ = world.get[Velocity](entity) We can check if an entity has a component using the has method.\n# Check if the entity has a velocity component if world.has[Velocity](entity): print(\"Entity has a velocity component\") else: print(\"Entity does not have a velocity component\") ","adding-and-removing-components#Adding and removing components":"Components can be added and removed from entities using the add and remove methods.\n# Add an entity without components entity = world.add_entity() # Add components to the entity world.add(entity, Position(0, 0), Velocity(1, 1)) # Remove a component from the entity world.remove[Velocity](entity) This works with arbitrary numbers of components, so we can add or remove any number of components at once.\nIf we want to remove some components and replace them with other components directly, we can use the replace method in combination with the by method. The replace method takes Components to be removed as parameters, whereas the by method takes the new components to be added.\n# Replace the position component with a velocity component world.replace[Position]().by(Velocity(2, 2), entity=entity) Similar to the add and remove methods, this works with arbitrary numbers of components, so we can replace any number of components with any other number of new components.\nTip\nReplacing components in one go is significantly more efficient than removing and adding components separately.\nBatch operations Sometimes you need to add or remove components from multiple entities at once. Larecsüå≤ provides batch operations that are more efficient than performing individual operations on each entity.\nBatch adding components You can add components to multiple entities that match a query using the add method with a query:\n# Add 10 entities with only Position components _ = world.add_entities(Position(0, 0), count=10) # Add Velocity component to all entities that have Position but not Velocity world.add( world.query[Position]().without[Velocity](), Velocity(1.0, 0.5) ) # You can also add multiple components at once to multiple entities world.add( world.query[Position]().without[Velocity](), Velocity(2.0, 1.0), # Additional components can be added here ) This is significantly more efficient than adding components to entities one by one:\n# Less efficient approach (avoid this for large numbers of entities) entities = List[Entity]() for entity in world.query[Position]().without[Velocity](): entities.append(entity) for entity in entities: world.add(entity, Velocity(1.0, 0.5)) # Individual operations Note\nCurrently, only batch adding of components is supported. Batch removal and replacement operations are planned for future releases. See the roadmap for more information.\nTip\nBatch operations are significantly more efficient than individual operations when working with large numbers of entities, as they minimize memory reorganization and improve cache locality.","setting-multiple-components-at-once#Setting multiple components at once":"We can set the values of multiple components at once using the set method. This method takes an arbitrary number of components and sets them all in one go.\n# Add an entity with two components entity = world.add_entity(Position(0, 0), Velocity(1, 1)) # Set multiple components at once world.set(entity, Position(5, 5), Velocity(2, 2)) "},"title":"Changing entities"},"/larecs/guide/entities_components_world/":{"data":{"":"Larecsüå≤ is an entity component system (ECS) framework for Mojo. The ECS concept is composed of three principal elements:\nEntities represent game objects or simulation entities, like individuals in a population model. Components are the data associated to entities, i.e. their properties or state variables. Systems contain the game or simulation logic that manipulates entities and their components, using so-called queries. In an ECS, each entity is ‚Äúcomposed of‚Äù an arbitrary set of components that can be added and removed at run-time. This modular design enables the development of highly flexible and reusable games or simulations. By decoupling the logic (systems) from the data (entities and components), ECS avoids convoluted inheritance hierarchies and eliminates hard-coded behavior. Instead, entities can be composed of components to exhibit diverse behaviors without sacrificing modularity.\nAn ECS engine manages this architecture within a central storage structure known as the ‚ÄúWorld‚Äù. The engine handles common tasks such as maintaining entity lists, spawning or deleting entities, and scheduling logic operations, simplifying the development process for users.\nLarecsüå≤ provides a high-performance ECS framework, empowering developers to create games and simulation models with exceptional flexibility and efficiency.","components#Components":"Components are the data associated with entities, characterizing their state and properties. Components are represented via structs: each component type is a different struct. For example, if we want to model a world in which entities may have a position and a velocity, we need to define a Position and a Velocity struct.\n@fieldwise_init struct Position(Copyable, Movable): var x: Float64 var y: Float64 @fieldwise_init struct Velocity(Copyable, Movable): var dx: Float64 var dy: Float64 These structs are not only used to store data. Their types are also used as unique identifiers for the components of an entity. That is, they have a similar role to a key in a dictionary.\nHow components can be assigned to entities is described in the following chapters.\nWarning\nCurrently, only ‚Äútrivial‚Äù structs are supported as components in Larecsüå≤. That is, structs that can be copied and moved via simple memory operations. This does not include structs that manage heap-allocated memory such as List or Dict. Typically, it is not advisable to use such objects in the ECS context anyway; however, Larecsüå≤ might support such ‚Äúcomplex‚Äù structs in a future version.","entities#Entities":"Entities are the central unit around which the data in an ECS is organized. Entities could represent game objects, or potentially anything else that ‚Äúlives‚Äù in a game or simulation. Each entity can possess an arbitrary set of components, which can also be used to characterize an entity. That is, in an ECS, cars would not be directly identified as ‚Äúcars‚Äù but rather as something that has the components Position, Velocity, Fuel reserves, Engine power, etc.\nThe components are not stored in individual objects but rather in a central container, called the World. Hence, an Entity is merely an identifier that allows retrieving the corresponding components from the world. As such, entities are strictly bound to the world they live in, but also small in memory and easy to store.\nNote\nThough entities can safely be stored and passed around, their components (or pointers to them) should never be stored externally, as they can move in memory at any time.\nHow entities are created and used is discussed in the next chapters.","the-world#The world":"The central data structure of Larecsüå≤ is the World. It stores all data and information about the state of the entities and their surroundings. The World struct provides the main functionality of the ECS, such as adding and removing entities, looking up components, and iterating over entities.\nLarecsüå≤ gains efficiency and usability by exploiting Mojo‚Äôs compile-time programming capabilities. To that end, it needs to know ahead of time which components might turn up in the world, and the World must be statically parameterized with the component types upon creation. This also has the advantage that certain errors can already be prevented at compile time, which makes the program safer and faster.\nTo set up a World, simply import it from the larecs package and create a World instance as follows:\nfrom larecs import World def main(): # Create a world with the components Position and Velocity world = World[Position, Velocity]() "},"title":"Entities, components and the world"},"/larecs/guide/installation/":{"data":{"":"Larecsüå≤ is written in and for Mojoüî•, which needs to be installed in order to compile, test, or use the software. You can build Larecsüå≤ as a package as follows:\nClone the repository / download the files. Navigate to the src/ subfolder. Execute mojo package larecs. Move the newly created file larecs.mojopkg to your project‚Äôs source directory. ","include-larecs-in-vscode-and-its-language-server#Include Larecsüå≤ in VSCode and its language server":"To let VSCode and its language server know of Larecsüå≤ (so that Ctrl-Click, mouse hover docs, autocomplete and error checking are available), include the package as follows:\nGo to VSCode‚Äôs File -\u003e Preferences -\u003e Settings page. Go to the Extensions -\u003e Mojo section. Look for the setting Lsp: Include Dirs. Click on add item and insert the path to the src/ subdirectory. ","include-the-source-directly-when-compiling#Include the source directly when compiling":"Instead of building Larecsüå≤ as a package, you can also include its source code directly when running or compiling your own project. This has the advantage that you can access the source while debugging and adjusting the Larecsüå≤ source code. You can include the Larecsüå≤ source code as follows:\nmojo run -I \"path/to/larecs/src\" example.mojo "},"title":"Installation"},"/larecs/guide/queries_iteration/":{"data":{"":"Iterating over entities can be done via classic for loops applied to queries, or via an apply operation, which applies a given function to all entities conforming to a query.","applying-functions-to-entities-in-queries#Applying functions to entities in queries":"We may want to apply a certain operation to all entities that have certain components. This can be achieved with the apply method. This method iterates over all entities conforming to a query and calls the provided function with the entities as arguments. The function must take a MutableEntityAccessor (an alias for EntityAccessor[True]) as its only argument. Applying a function to all entities can be more convenient and also faster than iterating over the entities manually, especially if the function is vectorized, as is shown in the vectorization chapter.\nFor example, if we want to apply a function that moves all entities with a Position and a Velocity component, we can do this as follows:\n# Define the move function fn move(entity: MutableEntityAccessor) capturing: try: ref move_pos = entity.get[Position]() ref move_vel = entity.get[Velocity]() move_pos.x += move_vel.dx move_pos.y += move_vel.dy except: # We could do proper error handling here # but for now, we just ignore the error pass # Apply the move function to all entities with a position and a velocity world.apply[move](world.query[Position, Velocity]()) Note\nCurrently, the applied operation can not raise exceptions. Therefore, we need to catch exceptions in the function itself. This is due to current limitations of Mojo and will be changed as soon as possible.\nCaution\nThe world is locked during the iteration, and accessing variables outside a locally defined function is an immature feature in Mojo. Do not attempt to access the world from inside the operation.","iterating-over-queries#Iterating over queries":"As we have seen, we can iterate over queries using a for loop. Here, the control variable (‚Äúentity‚Äù) is an EntityAccessor object, i.e., not technically an Entity, which is merely an identifier of an entity. Instead, the EntityAccessor directly provides methods to get, set, and check the existence of components, so that we do not need to call the world‚Äôs methods for this, making the code more efficient.\nfor entity in world.query[Position](): ref pos = entity.get[Position]() print( \"Entity at position: (\" + String(pos.x) + \", \" + String(pos.y) + \")\" ) if entity.has[Velocity](): ref vel = entity.get[Velocity]() # Also print the velocity print( \" - with velocity (\" + String(vel.dx) + \", \" + String(vel.dy) + \")\" ) Note\nThe EntityAccessor is a temporary object that is created for each iteration. Therefore, it should not be stored in a container. Use EntityAccessor.get_entity instead if you need to store the entity for later use.\nNote\nThe EntityAccessor can be implicitly converted to an Entity object and hence be used wherever an Entity is required.","preventing-iterator-invalidation-the-locked-world#Preventing iterator invalidation: the locked world":"Adding/removing entities to/from the world or components to/from entities while iterating could invalidate the iterator. That is, the iterator could leave out some entities or consider some entities multiple times. To prevent this, Larecsüå≤ locks the world during iterations. This means that methods that change how many entities exist in the world or which components entities have will raise exceptions if called during iteration.\nfor entity in world.query[Position](): # Adding entities to the world while iterating # is forbidden. with assert_raises(): _ = world.add_entity(Velocity(1, 0)) # Raises an exception # Changing components of an entity while iterating # is forbidden. with assert_raises(): _ = world.add(entity, Position(1, 2)) # Raises an exception If we want to add or remove components from entities while iterating, we need to store the entities in an intermediate container and iterate over them in a separate loop. Consider the following example, where we add a Velocity component to all entities that have a Position but no Velocity component:\n# A container for the entities entities = List[Entity]() for entity in world.query[Position]().without[Velocity](): # Store the entity for later use # The implicit conversion to `Entity` # allows us to use `entity` directly entities.append(entity) # Add a velocity component to all stored entities for entity in entities: # We can add components to the entity # because we are not iterating over the world _ = world.add(entity, Velocity(1, 0)) Note\nIn a later release, Larecsüå≤ will provide a batched version of the add and remove methods that will allow adding or removing components from multiple entities at once.","queries#Queries":"Queries allow to iterate over all entities with or without a specific set of components. To create a query, we can use the query method of World. The parameters used in this method are the components that each entity we look for must have. For example, if we want to iterate over all entities with a Position and a Velocity component, we can do this as follows:\n# Add entities with different components _ = world.add_entity() _ = world.add_entity(Position(0, 0)) _ = world.add_entity(Velocity(1, 0)) _ = world.add_entity(Position(1, 0), Velocity(1, 0)) # Query all entities that have a position query = world.query[Position]() # Of the entities we have just added, # two have a position component print(len(query)) # \"2\" # Now let us iterate over the queried entities for entity in query: ref pos = entity.get[Position]() print( \"Entity at position: (\" + String(pos.x) + \", \" + String(pos.y) + \")\" ) Queries can be adjusted to also exclude entities that have certain components. For example, if we want to iterate over all entities that have a Position component but not a Velocity component, we can do this using the without method:\nexcluding_query = world.query[Position]().without[Velocity]() print(len(excluding_query)) # \"1\" Furthermore, we can also query for entities that have exactly the components we are looking for but no more. This can be done using the exclusive method. For example, if we want to iterate over all entities that have only a Position component, we can do this as follows:\nexcluding_query = world.query[Position]().exclusive() print(len(excluding_query)) # \"1\" Note\nDetermining the length of a query is not a trivial operation and may require an internal iteration if the ECS involves many components. Therefore, it is advisable to avoid applying the len function to queries in ‚Äúhot‚Äù code. Nonetheless, the len function is much faster than counting entities manually by iterating over a query."},"title":"Queries and iteration"},"/larecs/guide/resources/":{"data":{"":"Not all data in a world is associated with\nspecific entities. This often applies to\nparameters (such as a time step),\nglobal state variables (such as the current time),\nor spatial data structures (such as a grid displaying\nentity positions). These data are called resources.","adding-and-accessing-resources#Adding and accessing resources":"Resources can be accessed and added via the resources field of World. Adding a resource is done via the resources.add method:\n# Add the `Time resource world.resources.add(Time(0.0)) The resources attribute also allows us to access and change resources via get and set methods resembling their component-related counterparts of World.\n# Change a resource value via a reference world.resources.get[Time]().time = 1.0 # Get a reference to a resource ref time = world.resources.get[Time]() # Change the resource value via the pointer time.time = 2.0 The add and the set methods also allow to add or set multiple resources at once. For example, consider the additional entities Temperature and SelectedEntities.\n@fieldwise_init struct Temperature(Copyable, Movable): var temperature: Float64 @fieldwise_init struct SelectedEntities(Copyable, Movable): var entities: List[Entity] We can add and set them as follows:\n# Add multiple resources world.resources.add( Temperature(20.0), SelectedEntities(List[Entity]()) ) # Set multiple resources world.resources.set( Temperature(30.0), Time(2.0) ) In contrast to components, resources can be ‚Äúcomplex‚Äù types with heap-allocated memory, as demonstrated above with SelectedEntities. We can use them to store arbitrary amounts of data.\n# Create entities and add them to the selected entities for i in range(10): entity = world.add_entity(Position(i, i)) world.resources.get[SelectedEntities]().entities.append(entity) ","defining-resources#Defining resources":"Similar to components, resources are defined via structs. That is, each resource has a specific type, and having two resources of the same type is not possible.\nHowever, in contrast to components, the (potentially) used resources do not need to be known at compile time but can be dynamically added to the world and are identified at runtime based on their struct name.\nfrom larecs import World, Entity @fieldwise_init struct Time(Copyable, Movable): var time: Float64 ","removing-resources#Removing resources":"One or multiple resources can be removed via the remove method. The existence of a resource is checked via the has method.\n# Remove the `Time` and the `Temperature` resource world.resources.remove[Time, Temperature]() # Check if the `Time` resource exists if world.resources.has[Time](): print(\"Time resource exists\") else: print(\"Time resource does not exist\") "},"title":"Resources"},"/larecs/guide/systems_scheduler/":{"data":{"":"A key feature of entity-component systems is that\noperations on the entities are organized in systems,\nwhich operate independently from one another and can\nbe added or removed as required.","scheduler#Scheduler":"The Scheduler is responsible for executing the systems in the correct order. A Scheduler contains a World instance and a list of systems. The scheduler has initialize, update, and finalize methods, which call the respective functions of all considered systems in the order they are added to the scheduler. In addition, the scheduler has a run method, which initializes the systems, runs them a desired number of times, and finalizes them.\nTo construct an example of a scheduler, let us define further systems for adding entities and logging their positions.\n@fieldwise_init struct AddMovers[count: Int](System): # This is executed once at the beginning fn initialize(mut self, mut world: World) raises: _ = world.add_entities( Position(0, 0), Velocity(1, 0), count=10 ) # This is executed in each step fn update(mut self, mut world: World) raises: # We do not need to do anything here pass # This is executed at the end fn finalize(mut self, mut world: World) raises: # We do not need to do anything here pass @fieldwise_init struct Logger[interval: Int](System): var _logging_step: Int fn __init__(out self): self._logging_step = 0 fn _print_positions(self, mut world: World) raises: for entity in world.query[Position, Velocity](): ref pos = entity.get[Position]() print(\"(\", pos.x, \",\", pos.y, \")\") # This is executed once at the beginning fn initialize(mut self, mut world: World) raises: print(\"Starting with\", len(world.query[Position, Velocity]()), \"moving entities.\") # This is executed in each step fn update(mut self, mut world: World) raises: if not self._logging_step % self.interval: print(\"Current Mover positions:\") self._print_positions(world) self._logging_step += 1 # This is executed at the end fn finalize(mut self, mut world: World) raises: print(\"Final positions:\") self._print_positions(world) Now we can create a scheduler and add the systems to it. Import the scheduler struct:\nfrom larecs import Scheduler Create and run the scheduler:\n# Create a scheduler scheduler = Scheduler[Position, Velocity]() # Add the systems to the scheduler scheduler.add_system(AddMovers[10]()) scheduler.add_system(Move()) scheduler.add_system(Logger[2]()) # Run the scheduler for 10 steps scheduler.run(10) ","systems#Systems":"Systems can be thought of as functions that take a World instance and perform operations on the world‚Äôs entities and/or resources. However, to allow storing intermediate variables between multiple system calls, and to support special initialization and finalization operations, systems are expressed as structs implementing the System trait. This trait requires systems to implement initialize, and finalize methods, called before or after the ECS run, respectively, and an update method, called at every step of the ECS run. Each of these methods takes a World instance on which they perform the desired operations.\nfrom larecs import World, System @fieldwise_init struct Move(System): # This is executed once at the beginning fn initialize(mut self, mut world: World) raises: # We do not need to do anything here pass # This is executed in each step fn update(mut self, mut world: World) raises: # Move all entities with a position and velocity for entity in world.query[Position, Velocity](): entity.get[Position]().x += entity.get[Velocity]().dx entity.get[Position]().y += entity.get[Velocity]().dy # This is executed at the end fn finalize(mut self, mut world: World) raises: # We do not need to do anything here pass "},"title":"Systems and the scheduler"},"/larecs/guide/vectorization/":{"data":{"":"A major feature of Mojo is its native support for vectorized operations, processing multiple values in one go via SIMD. This can improve the computational performance of our code significantly. In Larecsüå≤, this feature can be used by defining a vectorized function that can process multiple entities at once and applying it to entities via the apply method.\nCaution\nUsing vectorized functions is an an advanced feature, requiring some knowledge about Mojo and SIMD. Mistakes can lead to serious bugs that are difficult to track down.","applying-a-vectorized-operation-to-all-entities#Applying a vectorized operation to all entities":"What remains to be done is to apply the move operation to all entities. In the vectorized version, the apply method requires us to provide a value for the simd_width parameter, which denotes the maximal number of entities that can be processed at once efficiently. Typically, this corresponds to the SIMD width of our machine. We can get this information using the simdwidthof function.\n# How many `Float64` values can we process at once? alias simd_width=simdwidthof[Float64]() # Apply the move operation to all entities with a position and a velocity world.apply[move, simd_width=simd_width](world.query[Position, Velocity]()) Note\nThe overhead from the extra load and store operations can exceed the gain from SIMD operations in simple functions such as the move function considered here. Thorough benchmarking is required to determine whether the use of SIMD is beneficial in a specific case.","considering-the-memory-layout#Considering the memory layout":"Before we can implement a vectorized function that can process multiple entities at once, we need to have a look at the memory layout of the components we want to consider. Suppose we want to process the Position components of a chunk of entities. Each entity‚Äôs Position has two attributes x and y. In order to work with these attributes in vectorized computations, we need all x values and all y values to be in contiguous SIMD vectors, respectively.\nHowever, the x and y attributes are not stored next to each other in memory. Instead, an array of Position components would look like this:\nPosition[0].x | Position[0].y | Position[1].x | Position[1].y | ... Hence, accessing the x attribute of multiple Position components requires us to skip the y attributes.\nLoading elements from memory while leaving out some values is called strided loading. Here, stride refers to the ‚Äústep width‚Äù between the memory address of two loaded elements. In our case, the stride is 2, because the distance between the memory addresses from the first x attribute to the second is twice the size of a single x attribute.\nNote\nThe stride is given in multiples of the considered attribute‚Äôs size. While this makes it easy to work with components whose attributes are all of the same type, it may be tricky or even impossible to process components with heterogeneous attribute types.\nCaution\nChoosing the wrong stride may lead to undefined behavior,\ncausing crashes or errors that are extremely difficult to track down.\nWe may store the stride information in an alias variable.\nalias stride = 2 # Alternatively, we could use the `sizeof` function # to calculate the stride automatically. alias stride_ = Int(sizeof[Position]() / sizeof[__type_of(Position(0, 0).x)]()) Note that the Velocity component also has two Float64 attributes and thus the same stride as the Position component.","defining-a-vectorized-operation#Defining a vectorized operation":"Now we can define our vectorized move operation. It needs to accept an integer parameter simd_width, which denotes how many entities will be processed at once. Let us revisit the move function we defined in the queries and iteration chapter and add support for vectorized computation. The updated signature of the function reads as follows:\nfn move[simd_width: Int](entity: MutableEntityAccessor) capturing: Again we start implementing move by obtaining pointers to the Position and Velocity components.\ntry: pos = Pointer(to=entity.get[Position]()) vel = Pointer(to=entity.get[Velocity]()) except: return The entity argument is a normal mutable EntityAccessor instance, allowing access to a single entity. However, the referenced entity is the first of a batch of simd_width entities, each with the same components. The move function will not be called for any other entity in this batch.\nThe components of the batched entities are guaranteed to be stored in contiguous memory, respectively. However, loading a components‚Äô individual attributes in a batch is an ‚Äúunsafe‚Äù operation, as it requires us to specify the stride manually. Hence, we need UnsafePointers to the components.\npos_x_ptr = UnsafePointer(to=pos[].x) pos_y_ptr = UnsafePointer(to=pos[].y) vel_x_ptr = UnsafePointer(to=vel[].dx) vel_y_ptr = UnsafePointer(to=vel[].dy) Now we can load simd_width values of x and y into temporary SIMD vectors using the strided_load method and do the same for the dx and dy attributes of Velocity.\npos_x = pos_x_ptr.strided_load[width=simd_width](stride) pos_y = pos_y_ptr.strided_load[width=simd_width](stride) vel_x = vel_x_ptr.strided_load[width=simd_width](stride) vel_y = vel_y_ptr.strided_load[width=simd_width](stride) Next, we implement the actual ‚Äúmove‚Äù logic as if the vectors were simple scalars.\npos_x += vel_x pos_y += vel_y Finally, we store the updated positions at their original memory locations using the strided_store method.\npos_x_ptr.strided_store[width=simd_width](pos_x, stride) pos_y_ptr.strided_store[width=simd_width](pos_y, stride) Tip\nIt can be worthwhile to define project-specific load and store functions that take care of stride and width and thereby reduce the complexity of the code.","preliminary-imports#Preliminary imports":"Below, we need some advanced Mojo and Larecsüå≤ features, which we can import as follows:\nfrom memory import UnsafePointer from sys.info import simdwidthof, sizeof from larecs import World, MutableEntityAccessor "},"title":"Vectorization"},"/larecs/larecs/":{"data":{"aliases#Aliases":" MutableEntityAccessor = EntityAccessor[True, ?, ?, component_manager=?]: An entity accessor with mutable references to the components. ComponentType = Copyable \u0026 Movable: The trait that components must conform to. ResourceType = Copyable \u0026 Movable: The trait that resources must conform to. ","larecs#\u003ccode\u003elarecs\u003c/code\u003e":"Mojo package ü°≠\nlarecsLarecsüå≤ is a performance-oriented archetype-based ECS for Mojo.\nIt is based on the ECS Arche, implemented in the Go programming language.\nLarecsüå≤ is still under construction, so the API might change in future versions. It can, however, already be used for testing purposes.\nExample:\n# Import the package from larecs import World # Define components @fieldwise_init struct Position(Copyable, Movable): var x: Float64 var y: Float64 @fieldwise_init struct IsStatic(Copyable, Movable): pass @fieldwise_init struct Velocity(Copyable, Movable): var x: Float64 var y: Float64 # Run the ECS fn main() raises: # Create a world, list all components that will / may be used world = World[Position, Velocity, IsStatic]() for _ in range(100): # Add an entity. The returned value is the # entity's ID, which can be used to access the entity later entity = world.add_entity(Position(0, 0), IsStatic()) # For example, we may want to change the entity's position world.get[Position](entity).x = 2 # Or we may want to replace the IsStatic component # of the entity by a Velocity component world.replace[IsStatic]().by(Velocity(2, 2), entity=entity) # We can query entities with specific components for entity in world.query[Position, Velocity](): # get references to components ref position = entity.get[Position]() ref velocity = entity.get[Velocity]() position.x += velocity.x position.y += velocity.y ","structs#Structs":" EntityAccessor: Accessor for an Entity. Entity: Entity identifier. Holds an entity ID and it‚Äôs generation for recycling. Query: Query builder for entities with and without specific components. QueryInfo: Class that holds the same information as a query but no reference to the world. Resources: Manages resources. Scheduler: Manages the execution of systems in a world. Replacer: Replacer is a helper struct for removing and adding components to an Entity. World: World is the central type holding entity and component data, as well as resources. ","traits#Traits":" System: Trait for systems in the scheduler. "},"title":"API docs"},"/larecs/larecs/Entity/":{"data":{"entity#\u003ccode\u003eEntity\u003c/code\u003e":"Mojo struct ü°≠\nEntity @register_passable_trivial struct Entity Entity identifier. Holds an entity ID and it‚Äôs generation for recycling.\nEntities are only created via the World, using World.add_entity.\n‚ö†Ô∏è Important: Entities are intended to be stored and passed around via copy, not via pointers! The zero value should be used to indicate ‚Äúnil‚Äù, and can be checked with Entity.is_zero.","implemented-traits#Implemented traits":"AnyType, Boolable, Copyable, EqualityComparable, Hashable, Movable, Stringable, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __init__ fn __init__(accessor: EntityAccessor[archetype_mutability, archetype_origin, ComponentTypes, component_manager=component_manager]) -\u003e Self Initializes the entity from an EntityAccessor. Args:\naccessor (EntityAccessor): The entity accessor to initialize from. Returns:\nSelf\n__bool__ fn __bool__(self) -\u003e Bool Returns whether this entity is not the zero entity. Args:\nself (Self) Returns:\nBool\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Compares two entities for equality. Args:\nself (Self) other (Self): The other entity to compare to. Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Compares two entities for inequality. Args:\nself (Self) other (Self): The other entity to compare to. Returns:\nBool\n__str__ fn __str__(self) -\u003e String Returns a string representation of the entity. Args:\nself (Self) Returns:\nString\n__hash__ fn __hash__[H: Hasher](self, mut hasher: H) Returns a unique hash of the entity. Parameters:\nH (Hasher) Args:\nself (Self) hasher (H) get_id fn get_id(self) -\u003e SIMD[uint32, 1] Returns the entity‚Äôs ID. Args:\nself (Self) Returns:\nSIMD\nget_generation fn get_generation(self) -\u003e SIMD[uint32, 1] Returns the entity‚Äôs generation. Args:\nself (Self) Returns:\nSIMD\nis_zero fn is_zero(self) -\u003e Bool Returns whether this entity is the reserved zero entity. Args:\nself (Self) Returns:\nBool"},"title":"Entity"},"/larecs/larecs/EntityAccessor/":{"data":{"aliases#Aliases":" Archetype = Archetype[ComponentTypes, component_manager=component_manager]: The archetype of the entity. ","entityaccessor#\u003ccode\u003eEntityAccessor\u003c/code\u003e":"Mojo struct ü°≠\nEntityAccessor @memory_only struct EntityAccessor[archetype_mutability: Bool, archetype_origin: Origin[archetype_mutability], *ComponentTypes: Copyable \u0026 Movable, *, component_manager: ComponentManager[ComponentTypes]] Accessor for an Entity.\nCaution: use this only in the context it was created in. In particular, do not store it anywhere.","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all get_entity fn get_entity(self) -\u003e Entity Returns the entity of the accessor. Args:\nself (Self) Returns:\nEntity: The entity of the accessor.\nget fn get[T: Copyable \u0026 Movable](ref self) -\u003e ref [archetype_origin._mlir_origin._data] T Returns a reference to the given component of the Entity. Parameters:\nT (Copyable \u0026 Movable): The type of the component. Args:\nself (Self) Returns:\nref: A reference to the component of the entity.\nRaises:\nError: If the entity does not have the component.\nset fn set[*Ts: Copyable \u0026 Movable](mut self: EntityAccessor[True, archetype_origin, ComponentTypes, component_manager=component_manager], var *components: *Ts) Overwrites components for an Entity, using the given content. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components. Args:\nself (EntityAccessor) *components (*Ts): The new components. Raises:\nError: If the entity does not exist or does not have the component.\nhas fn has[T: Copyable \u0026 Movable](self) -\u003e Bool Returns whether an Entity has a given component. Parameters:\nT (Copyable \u0026 Movable): The type of the component. Args:\nself (Self) Returns:\nBool: Whether the entity has the component.","parameters#Parameters":" archetype_mutability (Bool): Whether the reference to the list is mutable. archetype_origin (Origin): The lifetime of the List. *ComponentTypes (Copyable \u0026 Movable): The types of the components. component_manager (ComponentManager): The component manager. "},"title":"EntityAccessor"},"/larecs/larecs/Query/":{"data":{"aliases#Aliases":" World = World[ComponentTypes] QueryWithWithout = Query[world_origin, ComponentTypes, has_without_mask=True] ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, SizedRaising, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __len__ fn __len__(self) -\u003e Int Returns the number of entities matching the query. Note that this requires the creation of an iterator from the query. If you intend to iterate anyway, get the iterator with Query.__iter__, and call len on it, instead.\nArgs:\nself (Self) Returns:\nInt\nRaises:\n__iter__ fn __iter__(self, out iterator: _EntityIterator[world_origin._mlir_origin._archetypes, world_origin._mlir_origin._locks, ComponentTypes, component_manager=ComponentManager(), has_without_mask=has_without_mask]) Creates an iterator over all entities that match the query. Args:\nself (Self) iterator (_EntityIterator) Returns:\n_EntityIterator: An iterator over all entities that match the query.\nRaises:\nError: If the lock cannot be acquired (more than 256 locks exist).\nwithout fn without[*Ts: Copyable \u0026 Movable](var self, out query: Query[world_origin, ComponentTypes, has_without_mask=True]) Excludes the given components from the query. world = World[Float64, Float32, Int]() _ = world.add_entity(Float64(1.0), Float32(2.0), 3) _ = world.add_entity(Float64(1.0), 3) for entity in world.query[Float64, Int]().without[Float32](): ref f = entity.get[Float64]() f += 1 Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components to exclude. Args:\nself (Self) query (Query) Returns:\nQuery: The query, excluding the given components.\nexclusive fn exclusive(var self, out query: Query[world_origin, ComponentTypes, has_without_mask=True]) Makes the query only match entities with exactly the query‚Äôs components. world = World[Float64, Float32, Int]() _ = world.add_entity(Float64(1.0), Float32(2.0), 3) _ = world.add_entity(Float64(1.0), 3) for entity in world.query[Float64, Int]().exclusive(): ref f = entity.get[Float64]() f += 1 Args:\nself (Self) query (Query) Returns:\nQuery: The query, made exclusive.","parameters#Parameters":" world_origin (MutableOrigin): The origin of the world. *ComponentTypes (Copyable \u0026 Movable): The types of the components to include in the query. has_without_mask (Bool): Whether the query has excluded components. ","query#\u003ccode\u003eQuery\u003c/code\u003e":"Mojo struct ü°≠\nQuery @memory_only struct Query[world_origin: MutableOrigin, *ComponentTypes: Copyable \u0026 Movable, *, has_without_mask: Bool = False] Query builder for entities with and without specific components.\nThis type should not be used directly, but through the World.query method:\nworld = World[Float64, Float32, Int]() _ = world.add_entity(Float64(1.0), Float32(2.0), 3) _ = world.add_entity(Float64(1.0), 3) for entity in world.query[Float64, Int](): ref f = entity.get[Float64]() f += 1 "},"title":"Query"},"/larecs/larecs/QueryInfo/":{"data":{"fields#Fields":" mask (BitMask) without_mask (StaticOptional[BitMask, has_without_mask]) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __init__ fn __init__(out self, query: Query[world_origin, ComponentTypes, has_without_mask=has_without_mask]) Takes the query info from an existing query. Args:\nquery (Query): The query the information should be taken from. self (Self) Returns:\nSelf\nmatches fn matches(self, archetype_mask: BitMask) -\u003e Bool Checks whether the given archetype mask matches the query. Args:\nself (Self) archetype_mask (BitMask): The mask of the archetype to check. Returns:\nBool: Whether the archetype matches the query.","parameters#Parameters":" has_without_mask (Bool): Whether the query has excluded components. ","queryinfo#\u003ccode\u003eQueryInfo\u003c/code\u003e":"Mojo struct ü°≠\nQueryInfo @memory_only struct QueryInfo[has_without_mask: Bool = False] Class that holds the same information as a query but no reference to the world.\nThis struct can be constructed implicitly from a Query instance. Therefore, Query instances can be used instead of QueryInfo in function arguments."},"title":"QueryInfo"},"/larecs/larecs/Replacer/":{"data":{"implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all by fn by[*AddTs: Copyable \u0026 Movable](self, entity: Entity, *components: *AddTs) Removes and adds the components to an Entity. Parameters:\n*AddTs (Copyable \u0026 Movable): The types of the components to add. Args:\nself (Self) entity (Entity): The entity to modify. *components (*AddTs): The components to add. Raises:\nError: when called for a removed (and potentially recycled) entity. Error: when called with components that can‚Äôt be added because they are already present. Error: when called with components that can‚Äôt be removed because they are not present. Error: when called on a locked world. Do not use during World.query iteration.\nfn by[*AddTs: Copyable \u0026 Movable](self, *components: *AddTs, *, entity: Entity) Removes and adds the components to an Entity. Parameters:\n*AddTs (Copyable \u0026 Movable): The types of the components to add. Args:\nself (Self) *components (*AddTs): The components to add. entity (Entity): The entity to modify. Raises:\nError: when called for a removed (and potentially recycled) entity. Error: when called with components that can‚Äôt be added because they are already present. Error: when called with components that can‚Äôt be removed because they are not present. Error: when called on a locked world. Do not use during World.query iteration.","parameters#Parameters":" world_origin (MutableOrigin): The mutable origin of the world. size (Int): The number of components to remove. *component_types (Copyable \u0026 Movable): The types of the components. ","replacer#\u003ccode\u003eReplacer\u003c/code\u003e":"Mojo struct ü°≠\nReplacer @memory_only struct Replacer[world_origin: MutableOrigin, size: Int, *component_types: Copyable \u0026 Movable] Replacer is a helper struct for removing and adding components to an Entity.\nIt stores the components to remove and allows adding new components in one go."},"title":"Replacer"},"/larecs/larecs/Resources/":{"data":{"aliases#Aliases":" IdType = StringSlice[StaticConstantOrigin]: The type of the internal type IDs. ","implemented-traits#Implemented traits":"AnyType, ExplicitlyCopyable, Movable, Sized, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __init__ fn __init__(out self) Constructs an empty resource container. Args:\nself (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Gets the number of stored resources. Args:\nself (Self) Returns:\nInt: The number of stored resources.\ncopy fn copy(self, out resources: Self) Creates a copy of the resources. Args:\nself (Self) resources (Self) Returns:\nSelf: A copy of the resources.\nadd fn add[*Ts: Copyable \u0026 Movable](mut self, var *resources: *Ts) Adds resources. Parameters:\n*Ts (Copyable \u0026 Movable): The Types of the resources to add. Args:\nself (Self) *resources (*Ts): The resources to add. Raises:\nError: If the resource already exists.\nset fn set[*Ts: Copyable \u0026 Movable, *, add_if_not_found: Bool = False](mut self, var *resources: *Ts) Sets the values of resources. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the resources to set. add_if_not_found (Bool): If true, adds resources that do not exist. Args:\nself (Self) *resources (*Ts): The resources to set. Raises:\nError: If one of the resources does not exist.\nremove fn remove[*Ts: Copyable \u0026 Movable](mut self) Removes resources. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the resources to remove. Args:\nself (Self) Raises:\nError: If one of the resources does not exist.\nget fn get[T: Copyable \u0026 Movable](mut self) -\u003e ref [*[0,0]._storage._entries._value.value._data] T Gets a resource. Parameters:\nT (Copyable \u0026 Movable): The type of the resource to get. Args:\nself (Self) Returns:\nref: A reference to the resource.\nRaises:\nhas fn has[T: Copyable \u0026 Movable](mut self) -\u003e Bool Checks if the resource is present. Parameters:\nT (Copyable \u0026 Movable): The type of the resource to check. Args:\nself (Self) Returns:\nBool: True if the resource is present, otherwise False.","resources#\u003ccode\u003eResources\u003c/code\u003e":"Mojo struct ü°≠\nResources @memory_only struct Resources Manages resources."},"title":"Resources"},"/larecs/larecs/Scheduler/":{"data":{"aliases#Aliases":" World = World[ComponentTypes]: The world type used by the scheduler. FunctionType = fn(mut system: UnsafeBox, mut world: World[ComponentTypes]) raises -\u003e None: The type of system functions. ","fields#Fields":" world (World[ComponentTypes]) ","implemented-traits#Implemented traits":"AnyType, Movable, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __init__ fn __init__(out self) Initializes the scheduler, creating a new world. Args:\nself (Self) Returns:\nSelf\nRaises:\nfn __init__(out self, var world: World[ComponentTypes]) Initializes the scheduler with a given world. Args:\nworld (World): The world to use. self (Self) Returns:\nSelf\nadd_system fn add_system[S: System](mut self, var system: S) Adds a system to the scheduler. Parameters:\nS (System) Args:\nself (Self) system (S): The system to add. initialize fn initialize(mut self) Initializes all systems in the scheduler. Args:\nself (Self) Raises:\nupdate fn update(mut self, steps: Int = 1) Updates all systems in the scheduler repeatedly. Args:\nself (Self) steps (Int): How often the systems should be updated. Raises:\nfinalize fn finalize(mut self) Finalizes all systems in the scheduler. Args:\nself (Self) Raises:\nrun fn run(mut self, steps: Int) Runs the scheduler for a given number of steps. This is the main entry point for running the scheduler. It calls the initialize, update, and finalize methods in order. The update method is called steps times. The initialize method is called once at the beginning, and the finalize method is called once at the end.\nArgs:\nself (Self) steps (Int): The number of steps to run. Raises:","parameters#Parameters":" *ComponentTypes (Copyable \u0026 Movable) ","scheduler#\u003ccode\u003eScheduler\u003c/code\u003e":"Mojo struct ü°≠\nScheduler @memory_only struct Scheduler[*ComponentTypes: Copyable \u0026 Movable] Manages the execution of systems in a world.\nThe systems must implement System. Usage example:\nExample:\n@fieldwise_init struct MySystem(System): var internal_variable: Int # This is executed once at the beginning fn initialize(mut self, mut world: World) raises: _ = world.add_entities(Position(0.0, 0.0), Velocity(1.0, 1.0), count=10) # This is executed in each step fn update(mut self, mut world: World) raises: for entity in world.query[Position, Velocity](): entity.get[Position]().x += entity.get[Velocity]().x entity.get[Position]().y += entity.get[Velocity]().y # This is executed at the end fn finalize(mut self, mut world: World) raises: print(\"Final positions\") for entity in world.query[Position](): print(entity.get[Position]().x, entity.get[Position]().y) scheduler = Scheduler[Position, Velocity]() scheduler.add_system(MySystem(internal_variable=42)) scheduler.run(10) "},"title":"Scheduler"},"/larecs/larecs/System/":{"data":{"implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __copyinit__ @staticmethod fn __copyinit__(out self: _Self, existing: _Self, /) Create a new instance of the value by copying an existing one. Args:\nexisting (_Self): The value to copy. self (_Self) Returns:\n_Self\n__moveinit__ @staticmethod fn __moveinit__(out self: _Self, var existing: _Self, /) Create a new instance of the value by moving the value of another. Args:\nexisting (_Self): The value to move. self (_Self) Returns:\n_Self\ninitialize fn initialize(mut self: _Self, mut world: World[component_types]) Initializes the system with the given world. Args:\nself (_Self) world (World): The world to use for initialization. Raises:\nupdate fn update(mut self: _Self, mut world: World[component_types]) Updates the system with the given world. Args:\nself (_Self) world (World): The world to use for the update. Raises:\nfinalize fn finalize(mut self: _Self, mut world: World[component_types]) Finalizes the system with the given world. Args:\nself (_Self) world (World): The world to use for the finalization. Raises:","system#\u003ccode\u003eSystem\u003c/code\u003e":"Mojo trait ü°≠\nSystemTrait for systems in the scheduler."},"title":"System"},"/larecs/larecs/World/":{"data":{"aliases#Aliases":" Id = SIMD[uint8, 1]\ncomponent_manager = ComponentManager()\nArchetype = Archetype[component_types, component_manager=ComponentManager()]\nQuery = Query[?, component_types, has_without_mask=?]\nIterator[archetype_mutability: Bool, //, archetype_origin: Origin, lock_origin: MutableOrigin, *, arch_iter_variant_idx: Int = 0, has_start_indices: Bool = False, has_without_mask: Bool = False]: AnyStruct[_EntityIterator[archetype_origin, lock_origin, component_types, component_manager=ComponentManager(), arch_iter_variant_idx=arch_iter_variant_idx, has_start_indices=has_start_indices, has_without_mask=has_without_mask]] = _EntityIterator[archetype_origin, lock_origin, component_types, component_manager=ComponentManager(), arch_iter_variant_idx=arch_iter_variant_idx, has_start_indices=has_start_indices, has_without_mask=has_without_mask]: Primary entity iterator type alias for the World. This flexible iterator supports different archetype iteration strategies via the arch_iter_variant_idx parameter, enabling optimized iteration patterns for different use cases:\nByMask iteration (default): Efficient for component-based queries\nByList iteration: Optimized for batch operations on known archetype sets\nPerformance Considerations: The iterator variant significantly affects performance - choose ByMask for general queries and ByList for batch operations where archetype sets are predetermined.\nArchetypeByMaskIterator[archetype_mutability: Bool, //, archetype_origin: Origin, has_without_mask: Bool = False]: AnyStruct[_ArchetypeByMaskIterator[archetype_origin, component_types, component_manager=ComponentManager(), has_without_mask=has_without_mask]] = _ArchetypeByMaskIterator[archetype_origin, component_types, component_manager=ComponentManager(), has_without_mask=has_without_mask]: Archetype iterator optimized for component mask-based queries. Efficiently iterates over archetypes by using bitmask operations to determine archetype matches. This is the preferred iterator for general ECS queries where you‚Äôre filtering entities based on component presence/absence. Optimizations:\nUses SIMD-optimized bitmask operations for fast archetype matching Skips empty archetypes automatically to reduce iteration overhead Supports exclusion masks via has_without_mask for complex filtering Best Use Cases:\nStandard component-based entity queries (e.g., entities with Position + Velocity) Complex queries with include/exclude component requirements Systems that iterate over entities matching specific component patterns ArchetypeByListIterator[archetype_mutability: Bool, //, archetype_origin: Origin]: AnyStruct[_ArchetypeByListIterator[archetype_origin, component_types, component_manager=ComponentManager()]] = _ArchetypeByListIterator[archetype_origin, component_types, component_manager=ComponentManager()]: Archetype iterator optimized for iteration over predetermined archetype sets. Iterates through a specific list of archetype indices without mask-based filtering. This iterator provides optimal performance when the set of archetypes to iterate is known in advance, such as during batch operations or cached query results. Performance Benefits:\nDirect archetype access without bitmask matching overhead Optimal for batch operations where archetype set is predetermined Cache-friendly iteration pattern for contiguous archetype ranges Minimal branching during iteration for maximum throughput Primary Use Cases:\nBatch entity creation (add_entities) where all entities use same archetype Cached query results where archetype set is pre-computed High-performance systems iterating over specific, known entity groups ArchetypeIterator[archetype_mutability: Bool, //, archetype_origin: Origin, arch_iter_variant_idx: Int = 0, has_without_mask: Bool = False]: AnyStruct[StaticVariant[arch_iter_variant_idx, _ArchetypeByMaskIterator[archetype_origin, component_types, component_manager=ComponentManager(), has_without_mask=has_without_mask], _ArchetypeByListIterator[archetype_origin, component_types, component_manager=ComponentManager()]]] = StaticVariant[arch_iter_variant_idx, _ArchetypeByMaskIterator[archetype_origin, component_types, component_manager=ComponentManager(), has_without_mask=has_without_mask], _ArchetypeByListIterator[archetype_origin, component_types, component_manager=ComponentManager()]] ","fields#Fields":" resources (Resources) ","implemented-traits#Implemented traits":"AnyType, ExplicitlyCopyable, Movable, Sized, UnknownDestructibility","methods#Methods":" Expand¬†all¬†¬† Collapse¬†all __init__ fn __init__(out self) Creates a new World. Args:\nself (Self) Returns:\nSelf\nRaises:\nfn __init__(out self, other: Self) Initializes a World by copying another instance. Args:\nother (Self): The other instance to copy. self (Self) Returns:\nSelf\n__moveinit__ @staticmethod fn __moveinit__(out self, var other: Self) Moves the contents of another World into a new one. Args:\nother (Self): The instance to move. self (Self) Returns:\nSelf\ncopy fn copy(self, out other: Self) Copies the contents of another World into a new one. Args:\nself (Self) other (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Returns the number of entities in the world. Note that this requires iterating over all archetypes and may be an expensive operation.\nArgs:\nself (Self) Returns:\nInt\nadd_entity fn add_entity[*Ts: Copyable \u0026 Movable](mut self, *components: *Ts, out entity: Entity) Returns a new or recycled Entity. The given component types are added to the entity. Do not use during World.query iteration!\n‚ö†Ô∏è Important: Entities are intended to be stored and passed around via copy, not via pointers! See Entity.\nExample:\nworld = World[Position, Velocity]() e = world.add_entity( Position(0, 0), Velocity(0.5, -0.5), ) Parameters:\n*Ts (Copyable \u0026 Movable): The components to add to the entity. Args:\nself (Self) *components (*Ts): The components to add to the entity. entity (Entity) Returns:\nEntity: The new or recycled Entity.\nRaises:\nError: If the world is locked.\nadd_entities fn add_entities[*Ts: Copyable \u0026 Movable](mut self, *components: *Ts, *, count: UInt, out iterator: _EntityIterator[self._archetypes, self._locks, component_types, component_manager=ComponentManager(), arch_iter_variant_idx=1, has_start_indices=True]) Adds a batch of Entitys. The given component types are added to the entities. Do not use during World.query iteration!\nExample:\nworld = World[Position, Velocity]() for entity in world.add_entities( Position(0, 0), Velocity(0.5, -0.5), count = 5 ): # Do things with the newly created entities position = entity.get[Position]() Parameters:\n*Ts (Copyable \u0026 Movable): The components to add to the entity. Args:\nself (Self) *components (*Ts): The components to add to the entity. count (UInt): The number of entities to add. iterator (_EntityIterator) Returns:\n_EntityIterator: An iterator to the new or recycled Entitys.\nRaises:\nError: If the world is locked.\nremove_entity fn remove_entity(mut self, entity: Entity) Removes an Entity, making it eligible for recycling. Do not use during World.query iteration!\nArgs:\nself (Self) entity (Entity): The entity to remove. Raises:\nError: If the world is locked or the entity does not exist.\nremove_entities fn remove_entities(mut self, query: QueryInfo[has_without_mask]) Removes multiple entities based on the provided query, making them eligible for recycling. Example:\nworld = World[Float32, Float64]() _ = world.add_entity(Float32(0)) _ = world.add_entity(Float32(0), Float64(0)) _ = world.add_entity(Float64(0)) # Remove all entities with a Float32 component. world.remove_entities(world.query[Float32]()) Args:\nself (Self) query (QueryInfo): The query to determine which entities to remove. Note, you can either use Query or QueryInfo. Raises:\nError: If the world is locked.\nis_alive fn is_alive(self, entity: Entity) -\u003e Bool Reports whether an Entity is still alive. Args:\nself (Self) entity (Entity): The entity to check. Returns:\nBool\nhas fn has[T: Copyable \u0026 Movable](self, entity: Entity) -\u003e Bool Returns whether an Entity has a given component. Parameters:\nT (Copyable \u0026 Movable): The type of the component. Args:\nself (Self) entity (Entity): The entity to check. Returns:\nBool\nRaises:\nError: If the entity does not exist.\nget fn get[T: Copyable \u0026 Movable](mut self, entity: Entity) -\u003e ref [*[0,0]._archetypes._data] T Returns a reference to the given component of an Entity. Parameters:\nT (Copyable \u0026 Movable): The type of the component. Args:\nself (Self) entity (Entity) Returns:\nref\nRaises:\nError: If the entity is not alive or does not have the component.\nset fn set[T: Copyable \u0026 Movable](mut self, entity: Entity, var component: T) Overwrites a component for an Entity, using the given content. Parameters:\nT (Copyable \u0026 Movable): The type of the component. Args:\nself (Self) entity (Entity): The entity to modify. component (T): The new component. Raises:\nError: If the Entity does not exist.\nfn set[*Ts: Copyable \u0026 Movable](mut self, entity: Entity, *components: *Ts) Overwrites components for an Entity using the given content. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components. Args:\nself (Self) entity (Entity): The entity to modify. *components (*Ts): The new components. Raises:\nError: If the entity does not exist or does not have the component.\nadd fn add[*Ts: Copyable \u0026 Movable](mut self, entity: Entity, *add_components: *Ts) Adds components to an Entity. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components to add. Args:\nself (Self) entity (Entity): The entity to modify. *add_components (*Ts): The components to add. Raises:\nError: when called for a removed (and potentially recycled) entity. Error: when called with components that can‚Äôt be added because they are already present. Error: when called on a locked world. Do not use during World.query iteration.\nfn add[*Ts: Copyable \u0026 Movable](mut self, *add_components: *Ts, *, entity: Entity) Adds components to an Entity. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components to add. Args:\nself (Self) *add_components (*Ts): The components to add. entity (Entity): The entity to modify. Raises:\nError: when called for a removed (and potentially recycled) entity. Error: when called with components that can‚Äôt be added because they are already present. Error: when called on a locked world. Do not use during World.query iteration.\nfn add[has_without_mask: Bool, //, *Ts: Copyable \u0026 Movable](mut self, query: QueryInfo[has_without_mask], var *add_components: *Ts, out iterator: _EntityIterator[self._archetypes, self._locks, component_types, component_manager=ComponentManager(), arch_iter_variant_idx=1, has_start_indices=True]) Adds components to multiple entities at once that are specified by a Query. The provided query must ensure that matching entities do not already have one or more of the components to add. Example:\nfrom larecs import World @fieldwise_init struct Position(Copyable, Movable): var x: Float64 var y: Float64 @fieldwise_init struct Velocity(Copyable, Movable): var x: Float64 var y: Float64 world = World[Position, Velocity]() _ = world.add_entities(Position(0, 0), 100) for entity in world.add[Velocity]( world.query[Position]().without_mask[Velocity](), Velocity(0.5, -0.5), ): velocity = entity.get[Velocity]() position = entity.get[Position]() entity.set[Position](Position(position.x + velocity.x, position.y + velocity.y)) entity.set[Velocity](Velocity(velocity.x - 0.05, velocity.y - 0.05)) Parameters:\nhas_without_mask (Bool): Whether the query has a without mask. *Ts (Copyable \u0026 Movable): The types of the components to add. Args:\nself (Self) query (QueryInfo): The query specifying which entities to modify. The query must explicitly exclude existing entities that already have some of the components to add. *add_components (*Ts): The components to add. iterator (_EntityIterator) Returns:\n_EntityIterator\nRaises:\nError: when called on a locked world. Do not use during World.query iteration. Error: when called with a query that could match existing entities that already have at least one of the components to add.\nremove fn remove[*Ts: Copyable \u0026 Movable](mut self, entity: Entity) Removes components from an Entity. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components to remove. Args:\nself (Self) entity (Entity): The entity to modify. Raises:\nError: when called for a removed (and potentially recycled) entity. Error: when called with components that can‚Äôt be removed because they are not present. Error: when called on a locked world. Do not use during World.query iteration.\nreplace fn replace[*Ts: Copyable \u0026 Movable](mut self) -\u003e Replacer[self, __len__(), component_types] Returns a Replacer for removing and adding components to an Entity in one go. Use as world.replace[Comp1, Comp2]().by(comp3, comp4, comp5, entity=entity).\nThe number of removed components does not need to match the number of added components.\nParameters:\n*Ts (Copyable \u0026 Movable): The types of the components to remove. Args:\nself (Self) Returns:\nReplacer\napply fn apply[operation: fn[MutableOrigin, Variadic[Copyable \u0026 Movable], ComponentManager[$1]](accessor: EntityAccessor[True, $0, $1, component_manager=$2]) capturing -\u003e None, *, unroll_factor: Int = 1](mut self, query: QueryInfo[has_without_mask]) Applies an operation to all entities with the given components. Parameters:\noperation (fn[MutableOrigin, Variadic[Copyable \u0026 Movable], ComponentManager[$1]](accessor: EntityAccessor[True, $0, $1, component_manager=$2]) capturing -\u003e None): The operation to apply. unroll_factor (Int): The unroll factor for the operation (see vectorize doc). Args:\nself (Self) query (QueryInfo): The query to determine which entities to apply the operation to. Raises:\nError: If the world is locked.\nfn apply[operation: fn[Int, MutableOrigin, Variadic[Copyable \u0026 Movable], ComponentManager[$2]](accessor: EntityAccessor[True, $1, $2, component_manager=$3]) capturing -\u003e None, *, simd_width: Int = 1, unroll_factor: Int = 1](mut self, query: QueryInfo[has_without_mask]) Applies an operation to all entities with the given components. The operation is applied to chunks of simd_width entities, unless not enough are available anymore. Then the chunk size simd_width is reduced.\nUses vectorize internally. Have a look there to see a more detailed explanation of the parameters simd_width and unroll_factor.\nCaution! If simd_width is greater than 1, the operation must apply to the simd_width elements after the element passed to operation, assuming that each component is stored in contiguous memory. This may require knowledge of the memory layout of the components!\nExample:\nfrom sys.info import simdwidthof from memory import UnsafePointer world = World[Float64]() e = world.add_entity() fn operation[simd_width: Int](accessor: MutableEntityAccessor) capturing: # Define the operation to apply here. # Note that due to the immature # capturing system of Mojo, the world may be # accessible by copy capturing here, even # though it is not copyable. # Do NOT change `world` from inside the operation, # as it will not be reflected in the world # or may cause a segmentation fault. try: # Get the component ref component = accessor.get[Float64]() # Get an unsafe pointer to the memory # location of the component ptr = UnsafePointer(to=component) except: return # Load a SIMD of size `simd_width` # Note that a strided load is needed if the component as more than one field. val = ptr.load[width=simd_width]() # Do an operation on the SIMD val += 1 # Store the SIMD at the same address ptr.store(val) world.apply[operation, simd_width=simdwidthof[Float64]()](world.query[Float64]()) Parameters:\noperation (fn[Int, MutableOrigin, Variadic[Copyable \u0026 Movable], ComponentManager[$2]](accessor: EntityAccessor[True, $1, $2, component_manager=$3]) capturing -\u003e None): The operation to apply. simd_width (Int): The SIMD width for the operation (see vectorize doc). unroll_factor (Int): The unroll factor for the operation (see vectorize doc). Args:\nself (Self) query (QueryInfo): The query to determine which entities to apply the operation to. Raises:\nError: If the world is locked.\nquery fn query[*Ts: Copyable \u0026 Movable](mut self, out iterator: Query[self, component_types]) Returns an Query for all Entities with the given components. Parameters:\n*Ts (Copyable \u0026 Movable): The types of the components. Args:\nself (Self) iterator (Query) Returns:\nQuery: A Query for all entities with the given components.\nis_locked fn is_locked(self) -\u003e Bool Returns whether the world is locked by any queries. Args:\nself (Self) Returns:\nBool","parameters#Parameters":" *component_types (Copyable \u0026 Movable) ","world#\u003ccode\u003eWorld\u003c/code\u003e":"Mojo struct ü°≠\nWorld @memory_only struct World[*component_types: Copyable \u0026 Movable] World is the central type holding entity and component data, as well as resources.\nThe World provides all the basic ECS functionality of Larecs, like World.query, World.add_entity, World.add, World.remove, World.get or World.remove_entity."},"title":"World"}}